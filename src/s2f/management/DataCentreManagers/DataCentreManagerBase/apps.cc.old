// Used to contain a boolean array indicating free slots inside a AppsVector -> delegated to hypervisor
// bool *getAppsRunningInVectorModuleByVm(const std::string &vmId) { return getOrNull(mapAppsRunningInVectorModulePerVm, vmId); }

// Helpers to locate the applications
// cModule *getFreeAppModuleInVector(const std::string &vmId);
// cModule *getAppsVectorModulePerVm(const std::string &vmId) { return getOrNull(mapAppsVectorModulePerVm, vmId); }

void DataCentreManagerBase::acceptAppRequest(SM_UserAPP *userAPP_Rq, std::string strVmId)
{
    EV_INFO << "Sending vm end to the CP:" << userAPP_Rq->getUserID() << '\n';

    SM_UserAPP *userAPP_Res = userAPP_Rq->dup();
    EV_INFO << *userAPP_Res << '\n';

    userAPP_Res->setVmId(strVmId.c_str());
    userAPP_Res->setFinished(true);

    // Fill the message
    userAPP_Res->setIsResponse(true);
    userAPP_Res->setOperation(SM_APP_Rsp);
    userAPP_Res->setResult(SM_APP_Res_Accept);

    // Send the values
    sendResponseMessage(userAPP_Res);
}

void DataCentreManagerBase::rejectAppRequest(SM_UserAPP *userAPP_Rq)
{
    // Create a request_rsp message
    EV_INFO << "Rejecting app request from user:" << userAPP_Rq->getUserID() << '\n';

    // Fill the message
    userAPP_Rq->setIsResponse(true);
    userAPP_Rq->setOperation(SM_APP_Req);
    userAPP_Rq->setResult(SM_APP_Res_Reject);

    // Send the values
    sendResponseMessage(userAPP_Rq);
}

void DataCentreManagerBase::handleUserAppRequest(SIMCAN_Message *sm)
{
    EV_INFO << LogUtils::prettyFunc(__FILE__, __func__) << " - Handle AppRequest" << '\n';

    // Cast request
    auto userAPP_Rq = check_and_cast<SM_UserAPP *>(sm);
    std::string userId = userAPP_Rq->getUserID();

    // Sanity check
    if (userAPP_Rq->getAppArraySize() < 1)
        error("[%s] The list of applications of the user: %s is empty!!", LogUtils::prettyFunc(__FILE__, __func__).c_str(), userId.c_str());

    // FIXME: The behaviour for rejecting app requests is not defined!
    // Prepare context
    ApplicationBuilder::Context ctx;
    bool bHandle = false;
    ctx.userId = &userId;

    // Print the request
    EV_INFO << *userAPP_Rq << '\n';

    for (unsigned int i = 0; i < userAPP_Rq->getAppArraySize(); i++)
    {
        // Get the app
        APP_Request userApp = userAPP_Rq->getApp(i);

        if (userApp.eState == appFinishedOK || userApp.eState == appFinishedError)
            continue;

        // Fill the context
        ctx.appId = &userApp.strApp;
        ctx.vmId = &userApp.vmId;
        ctx.schema = dataManager->searchApp(userApp.strAppType);

        if (ctx.schema == nullptr)
            error("%s - Unable to find App. Wrong AppType [%s]?", LogUtils::prettyFunc(__FILE__, __func__).c_str(), userApp.strAppType.c_str());

        // Locate the free "app slot"
        cModule *pVmAppModule = getFreeAppModuleInVector(userApp.vmId);
        if (pVmAppModule == nullptr)
            continue;

        // Build the application
        appBuilder->build(pVmAppModule, ctx);

        userAPP_Rq->changeState(userApp.strApp, userApp.vmId, appRunning);
    }
    bHandle = true;

    if (!bHandle)
    {
        rejectAppRequest(userAPP_Rq);
        return;
    }

    // Search for the app in manager map
    auto appIt = handlingAppsRqMap.find(userId);
    if (appIt == handlingAppsRqMap.end())
    {
        // Registering the appRq
        handlingAppsRqMap[userId] = userAPP_Rq;
    }
    else
    {
        SM_UserAPP *uapp = appIt->second;
        uapp->update(userAPP_Rq);
        delete userAPP_Rq; // Delete ephemeral message after update global message.
    }
}

void DataCentreManagerBase::checkAllAppsFinished(SM_UserAPP *pUserApp, std::string strVmId)
{
    assert_msg(pUserApp != nullptr, "Nullpointer in argument detected!");

    auto userId = pUserApp->getUserID();

    if (!pUserApp->allAppsFinished(strVmId))
    {
        EV_INFO << LogUtils::prettyFunc(__FILE__, __func__)
                << " - Total apps finished: "
                << pUserApp->getNFinishedApps() << " of "
                << pUserApp->getAppArraySize() << '\n';
        return;
    }

    if (pUserApp->allAppsFinishedOK(strVmId))
    {
        EV_INFO << LogUtils::prettyFunc(__FILE__, __func__)
                << " - All the apps corresponding with the user "
                << userId
                << " have finished successfully" << '\n';

        EV_INFO << *pUserApp << '\n';

        // Notify the user the end of the execution
        acceptAppRequest(pUserApp, strVmId);
    }
    else
    {
        EV_INFO << LogUtils::prettyFunc(__FILE__, __func__)
                << " - All the apps corresponding with the user "
                << userId
                << " have finished with some errors" << '\n';

        // Check the subscription queue
        // updateSubsQueue();

        // if (!pUserApp->getFinished())
        timeoutAppRequest(pUserApp, strVmId); // Notify the user the end of the execution
    }

    // Delete the application on the hashmap
    // handlingAppsRqMap.erase(userId);
}

void DataCentreManagerBase::timeoutAppRequest(SM_UserAPP *userAPP_Rq, std::string strVmId)
{
    EV_INFO << "Sending timeout to the user:" << userAPP_Rq->getUserID() << '\n';
    EV_INFO << "Last id gate: " << userAPP_Rq->getLastGateId() << '\n';

    SM_UserAPP *userAPP_Res = userAPP_Rq->dup(strVmId);
    EV_INFO << *userAPP_Res << '\n';

    userAPP_Res->setVmId(strVmId.c_str());

    // Fill the message
    userAPP_Res->setIsResponse(true);
    userAPP_Res->setOperation(SM_APP_Rsp);
    userAPP_Res->setResult(SM_APP_Res_Timeout);

    // Send the values
    sendResponseMessage(userAPP_Res);
}

void DataCentreManagerBase::abortAllApps(std::string strVmId)
{
    cModule *pAppModule, *pVmAppModule, *pVmAppVectorModule = getAppsVectorModulePerVm(strVmId);
    bool *appRunningArr = getAppsRunningInVectorModuleByVm(strVmId);
    int numMaxApps = pVmAppVectorModule->par("numApps");

    for (int i = 0; i < numMaxApps; i++)
    {
        if (appRunningArr[i])
        {
            pVmAppModule = pVmAppVectorModule->getSubmodule("appModule", i);
            // deleteAppFromModule(pVmAppModule);
            storeAppFromModule(pVmAppModule);
            createDummyAppInAppModule(pVmAppModule);
            appRunningArr[i] = false;
        }
    }
}

void DataCentreManagerBase::storeAppFromModule(cModule *pVmAppModule)
{
    cModule *pDummyAppModule = pVmAppModule->getSubmodule("app");
    pVmAppModule->gate("fromHub")->disconnect();
    pVmAppModule->gate("toHub")->getPreviousGate()->disconnect();
    pDummyAppModule->changeParentTo(this);
    std::string appInstance = pDummyAppModule->par("appInstance");
    LocalApplication *ptrAppInstance = dynamic_cast<LocalApplication *>(pDummyAppModule);
    unsigned int *appStateArr = new unsigned int[2];
    appStateArr[0] = ptrAppInstance->getCurrentIteration();
    appStateArr[1] = ptrAppInstance->getCurrentRemainingMIs();
    // ptrAppInstance->sendAbortRequest();
    mapAppsModulePerId[appInstance] = appStateArr;
    pDummyAppModule->deleteModule();
}

cModule *DataCentreManagerBase::getFreeAppModuleInVector(const std::string &vmId)
{
    cModule *appVector = getAppsVectorModulePerVm(vmId);
    if (appVector == nullptr)
        error("[%s] There is no app ventor module for the VM!!", LogUtils::prettyFunc(__FILE__, __func__).c_str());

    int numMaxApps = appVector->par("numApps");
    bool *runningAppsArr = getAppsRunningInVectorModuleByVm(vmId);

    for (int i = 0; i < numMaxApps; i++)
    {
        if (!runningAppsArr[i])
        {
            runningAppsArr[i] = true;
            return appVector->getSubmodule("appModule", i);
        }
    }

    return nullptr;
}

void DataCentreManagerBase::handleAppExecEndSingle(std::string strUsername, std::string strVmId, std::string strAppName, int appIndexInVector)
{
    SM_UserAPP *pUserApp;
    pUserApp = getUserAppRequestPerUser(strUsername);

    if (pUserApp == nullptr)
        throw omnetpp::cRuntimeError(("[" + LogUtils::prettyFunc(__FILE__, __func__) + "] There is no app request message from the User!!!").c_str());

    //    endSingleAppResponse(pUserApp, strVmId, strAppName);
    //    scheduleAppTimeout(EXEC_APP_END_SINGLE, strUsername, strAppName, strVmId, SimTime());

    EV_INFO << "The execution of the App [" << strAppName << " / " << strVmId
            << "] launched by the user " << strUsername << " has finished" << '\n';

    pUserApp->increaseFinishedApps();
    // Check for a possible timeout
    if (!pUserApp->isFinishedKO(strAppName, strVmId))
    {
        EV_INFO << LogUtils::prettyFunc(__FILE__, __func__)
                << " - Changing status of the application [ app: "
                << strAppName << " | vmId: " << strVmId << '\n';
        EV_INFO << *pUserApp << '\n';

        pUserApp->changeState(strAppName, strVmId, appFinishedOK);
    }

    cModule *pVmAppVectorModule = nullptr;
    bool *runningAppsArr;

    pVmAppVectorModule = getAppsVectorModulePerVm(strVmId);

    if (pVmAppVectorModule == nullptr)
        throw omnetpp::cRuntimeError(("[" + LogUtils::prettyFunc(__FILE__, __func__) + "] There is no app ventor module for the VM!!").c_str());

    int numMaxApps = pVmAppVectorModule->par("numApps");

    if (appIndexInVector >= numMaxApps)
        throw omnetpp::cRuntimeError(("[" + LogUtils::prettyFunc(__FILE__, __func__) + "] There is no app ventor module for the VM!!").c_str());

    runningAppsArr = getAppsRunningInVectorModuleByVm(strVmId);

    if (runningAppsArr == nullptr)
        throw omnetpp::cRuntimeError(("[" + LogUtils::prettyFunc(__FILE__, __func__) + "] There is no app runing vector for the VM!!").c_str());

    runningAppsArr[appIndexInVector] = false;
}

void DataCentreManagerBase::cleanAppVectorModule(cModule *pVmAppVectorModule)
{
    cModule *pVmAppModule = nullptr;

    int numMaxApps = pVmAppVectorModule->par("numApps");

    for (int i = 0; i < numMaxApps; i++)
    {
        pVmAppModule = pVmAppVectorModule->getSubmodule("appModule", i);
        // Disconnect and delete dummy app
        appBuilder->deleteApp(pVmAppModule);
        createDummyAppInAppModule(pVmAppModule);
    }
}

void DataCentreManagerBase::createDummyAppInAppModule(cModule *pVmAppModule)
{
    std::string strAppType = "s2f.Applications.UserApps.DummyApp.DummyApplication";
    cModuleType *moduleType = cModuleType::get(strAppType.c_str());

    if (pVmAppModule == nullptr)
        return;

    cModule *moduleApp = moduleType->create("app", pVmAppModule);
    moduleApp->finalizeParameters();

    pVmAppModule->gate("fromHub")->connectTo(moduleApp->gate("in"));
    moduleApp->gate("out")->connectTo(pVmAppModule->gate("toHub"));

    // create internals, and schedule it
    moduleApp->buildInside();
    moduleApp->scheduleStart(simTime());
    moduleApp->callInitialize();
}