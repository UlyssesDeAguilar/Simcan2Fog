// TODO: asignar la vm que hace el timout al mensaje de la app. Duplicarlo y enviarlo.
void DataCentreManagerBase::handleExecVmRentTimeout(cMessage *msg)
{
    SM_UserAPP *pUserApp;
    DcHypervisor *pHypervisor;

    std::string strUsername,
        strVmId,
        strVmType,
        strAppName,
        strIp;

    bool bAlreadyFinished;

    SM_UserVM_Finish *pUserVmFinish;

    std::map<std::string, SM_UserAPP *>::iterator it;

    pUserVmFinish = dynamic_cast<SM_UserVM_Finish *>(msg);
    if (pUserVmFinish == nullptr)
        error("%s - Unable to cast msg to SM_UserVM_Finish*. Wrong msg name [%s]?", LogUtils::prettyFunc(__FILE__, __func__).c_str(), msg->getName());

    EV_INFO << LogUtils::prettyFunc(__FILE__, __func__) << " - INIT" << '\n';
    strVmId = pUserVmFinish->getStrVmId();
    strVmType = pUserVmFinish->getStrVmType();

    strUsername = pUserVmFinish->getUserID();
    EV_INFO << "The rent of the VM [" << strVmId
            << "] launched by the user " << strUsername
            << " has finished" << '\n';

    deallocateVmResources(strVmId);
    // nTotalAvailableCores += getTotalCoresByVmType(strVmType); TODO FIX THIS

    pUserApp = getUserAppRequestPerUser(strUsername);

    if (pUserApp == nullptr)
        throw omnetpp::cRuntimeError(("[" + LogUtils::prettyFunc(__FILE__, __func__) + "] There is no app request message from the User!!").c_str());

    //    acceptAppRequest(pUserApp, strVmId);

    // Check the Application status

    EV_INFO << "Last id gate: " << pUserApp->getLastGateId() << '\n';
    EV_INFO << "Checking the status of the applications which are running over this VM\n";

    // Abort the running applications
    if (!pUserApp->allAppsFinished(strVmId))
    {
        EV_INFO << "Aborting running applications\n";
        abortAllApps(strVmId);
        pUserApp->abortAllApps(strVmId);
    }
    // Check the result and send it
    checkAllAppsFinished(pUserApp, strVmId);

    EV_INFO << "Freeing resources...\n";

    // Delete the event!
    delete msg;
}

// En dcManagerCost hace todo exactamente igual expto en el if de la línea 48 donde camibia el cuerpo
void DataCentreManagerCost::handleExecVmRentTimeout(cMessage *msg)
{
    ...

    // Abort the running applications
    if (!pUserApp->allAppsFinished(strVmId))
    {
        EV_INFO << "Aborting running applications" << '\n';
        abortAllApps(strVmId);
        pUserApp->abortAllApps(strVmId);
    }
    else
    {
        deallocateVmResources(strVmId);
        strVmType = pUserVmFinish->getStrVmType();
        nTotalAvailableCores += getTotalCoresByVmType(strVmType);
    }
    
    ...
}

// void DataCentreManagerBase::deallocateVmResources(std::string strVmId)
// {
//     DcHypervisor *pHypervisor = getNodeHypervisorByVm(strVmId);
// 
//     if (pHypervisor == nullptr)
//         error("%s - Unable to deallocate VM. Wrong VM name [%s]?", LogUtils::prettyFunc(__FILE__, __func__).c_str(), strVmId.c_str());
// 
//     pHypervisor->deallocateVmResources(strVmId);
//     manageActiveMachines();
// }

// Versión más correcta y completa de BestFit: Reajusta los buckets al hacer deallocate! -> Relevante para el hypervisor/hardwaremanager/resourcemanager
//
// void DataCentreManagerBestFit::deallocateVmResources(std::string strVmId)
// {
//     DcHypervisor *pHypervisor = getNodeHypervisorByVm(strVmId);
//
//     if (pHypervisor == nullptr)
//         error("%s - Unable to deallocate VM. Wrong VM name [%s]?", LogUtils::prettyFunc(__FILE__, __func__).c_str(), strVmId.c_str());
//
//     removeNodeFromMap(pHypervisor);
//
//     pHypervisor->deallocateVmResources(strVmId);
//
//     storeNodeInMap(pHypervisor);
//
//     updateCpuUtilizationTimeForHypervisor(pHypervisor);
//     manageActiveMachines();
// }